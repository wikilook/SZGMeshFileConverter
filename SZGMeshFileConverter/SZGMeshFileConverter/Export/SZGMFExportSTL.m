//
//  SZGMFExportSTL.m
//  SZGMeshFileConverter
//
//  Created by Gábor Szalai on 2019. 01. 12..
//  Copyright © 2019. Gábor Szalai. All rights reserved.
//

#define STL_HEADER @"---Generated by: SZGMeshFileConverter--"

#import "SZGMFExportSTL.h"
#import "SZGMFMesh+Helper.h"
#import "SZGMFFace.h"

@implementation SZGMFExportSTL

- (void) exportFileWithPath: (NSString*)filePath mesh:(SZGMFMesh*)mesh
{
    // Before export we try to triangulate the faces of the mesh
    [mesh triangulateFaces];
    
    // Create the output file to write into and get a handle
    [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil];
    NSFileHandle* file = [NSFileHandle fileHandleForWritingAtPath:filePath];
    
    // write the header into the file
    [self addHeaderToFile:file];
    
    // write the facecount into the file
    [self addNumberOfFacesToFile:file fromFaces:mesh.faces];
    
    // and export all the faces into the file
    [self addFacesToFile:file fromMesh:mesh];
    
    [file closeFile];
}

- (void) addHeaderToFile:(NSFileHandle*)file
{
    // The header can hold anything up to 80 bytes, lets just put the name of our framework in there
    NSString* header = STL_HEADER;
    NSData* headerData = [header dataUsingEncoding:NSUTF16StringEncoding];
    
    [file writeData:headerData];
}

- (void) addNumberOfFacesToFile:(NSFileHandle*)file fromFaces:(NSArray*)faces
{
    // Write the number of faces into the file in 4 bytes
    uint32_t length = (uint32_t)[faces count];
    NSData* facesSizeData = [NSData dataWithBytes:&length length:4];
    [file writeData: facesSizeData];
}

- (void) addFacesToFile:(NSFileHandle*)file fromMesh:(SZGMFMesh*)mesh
{
    // Loop through all the faces
    for (int i = 0; i < [mesh.faces count]; i++)
    {
        SZGMFFace* currentFace = mesh.faces[i];
        
        // And Loop through the vertexindices of the face
        // We triangulated it and it should only hold 3 elements, so we onyl hit the loop once optimally
        for (int j = 0; j < [currentFace.vertexIndices count]; j+=3)
        {
            // Get the 3 GLKVector3 out of the NSValues Where we stored them
            NSNumber* vertexIndex = currentFace.vertexIndices[j];
            NSValue* vertex = mesh.vertices[[vertexIndex longLongValue] - 1];
            GLKVector3 vertexV3_1;
            [vertex getValue:&vertexV3_1];
            
            vertexIndex = currentFace.vertexIndices[j+1];
            vertex = mesh.vertices[[vertexIndex longLongValue] - 1];
            GLKVector3 vertexV3_2;
            [vertex getValue:&vertexV3_2];
            
            vertexIndex = currentFace.vertexIndices[j+2];
            vertex = mesh.vertices[[vertexIndex longLongValue] - 1];
            GLKVector3 vertexV3_3;
            [vertex getValue:&vertexV3_3];
            
            // Also get the normals
            // Again these are optional so we need to be aware
            long long normalIndex1 = ([currentFace.normalIndices count] > j) ?  [currentFace.normalIndices[j] longLongValue] : -1;
            NSValue* normal1 = normalIndex1 != -1 ? mesh.normals[normalIndex1 - 1] : nil;
            
            long long normalIndex2 = ([currentFace.normalIndices count] > j+1) ?  [currentFace.normalIndices[j+1] longLongValue] : -1;
            NSValue* normal2 = normalIndex2 != -1 ? mesh.normals[normalIndex2 - 1] : nil;
            
            long long normalIndex3 = ([currentFace.normalIndices count] > j+2) ?  [currentFace.normalIndices[j+2] longLongValue] : -1;
            NSValue* normal3 = normalIndex3 != -1 ? mesh.normals[normalIndex3 - 1] : nil;
            
            GLKVector3 faceNormal;
            GLKVector3 positions[3] = {vertexV3_1, vertexV3_2, vertexV3_3};
            
            if (normal1 != nil && normal2 != nil && normal3 != nil)
            {
                // If we actually have normal vertices calculate the face normal using them
                GLKVector3 normalV3_1;
                [normal1 getValue:&normalV3_1];
                GLKVector3 normalV3_2;
                [normal2 getValue:&normalV3_2];
                GLKVector3 normalV3_3;
                [normal3 getValue:&normalV3_3];
                GLKVector3 normals[3] = {normalV3_1, normalV3_2, normalV3_3};
                faceNormal = [self calculateNormalForFacePositions:positions normals:normals];
            }
            else
            {
                // If not just use the positions
                faceNormal = [self calculateNormalForFacePositions:positions];
            }
            
            /*
             
             Left this log here to make it easier to see what goes into the binary,
             it is a bit more harder to read it in a hexreader :)
             
            NSLog(@"face normal: %f, %f, %f", faceNormal.x, faceNormal.y, faceNormal.z);
            NSLog(@"v1: %lld, %f, %f, %f", normalIndex1, vertexV3_1.x, vertexV3_1.y, vertexV3_1.z);
            NSLog(@"v2: %lld, %f, %f, %f", normalIndex2, vertexV3_2.x, vertexV3_2.y, vertexV3_2.z);
            NSLog(@"v3: %lld, %f, %f, %f", normalIndex3, vertexV3_3.x, vertexV3_3.y, vertexV3_3.z);
            
            NSLog(@"vertex float size: %lu", [[NSData dataWithBytes:&faceNormal.x length:sizeof(float)] length]);
             */
            
            // Write the face normal and the position vertices into the file
            // We are using float which is stored in 4 bytes just as we need it
            
            [file writeData: [NSData dataWithBytes:&faceNormal.x length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&faceNormal.y length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&faceNormal.z length:sizeof(float)]];
            
            [file writeData: [NSData dataWithBytes:&vertexV3_1.x length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&vertexV3_1.y length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&vertexV3_1.z length:sizeof(float)]];
            
            [file writeData: [NSData dataWithBytes:&vertexV3_2.x length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&vertexV3_2.y length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&vertexV3_2.z length:sizeof(float)]];
            
            [file writeData: [NSData dataWithBytes:&vertexV3_3.x length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&vertexV3_3.y length:sizeof(float)]];
            [file writeData: [NSData dataWithBytes:&vertexV3_3.z length:sizeof(float)]];
            
            // Add the last part of the face block to the file (2 bytes)
            unsigned short attributesCount = 0;
            NSData* attrCountData = [NSData dataWithBytes:&attributesCount length:sizeof(unsigned short)];
            
            [file writeData: attrCountData];
        }
    }
}

- (GLKVector3) calculateNormalForFacePositions:(GLKVector3[3])positions
{
    // Face normal calculation from the position vertices
    GLKVector3 corner0 = GLKVector3Subtract(positions[1], positions[0]);
    GLKVector3 corner1 = GLKVector3Subtract(positions[2], positions[0]);
    GLKVector3 faceNormal = GLKVector3CrossProduct(corner0, corner1);
    
    return faceNormal;
}

- (GLKVector3) calculateNormalForFacePositions:(GLKVector3[3])positions normals:(GLKVector3[3])normals
{
    // Face normal calculation from the position vertices and normal vertices
    GLKVector3 faceNormal = [self calculateNormalForFacePositions:positions];
    
    GLKVector3 averageVertexNormals = GLKVector3DivideScalar(GLKVector3Add(normals[0], GLKVector3Add(normals[1], normals[2])), 3);
    
    float dot = GLKVector3DotProduct(faceNormal, averageVertexNormals);
    
    return (dot < 0.0f) ? GLKVector3Negate(faceNormal) : faceNormal;
}

@end
